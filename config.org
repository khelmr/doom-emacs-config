#+title: Doom Emacs Config
#+startup: fold

* Doom
** Init
#+begin_src elisp :tangle init.el
;;; init.el -*- lexical-binding: t; -*-
;; This file controls what Doom modules are enabled and what order they load
;; in. Remember to run 'doom sync' after modifying it!

;; NOTE Press 'SPC h d h' (or 'C-h d h' for non-vim users) to access Doom's
;;      documentation. There you'll find a link to Doom's Module Index where all
;;      of our modules are listed, including what flags they support.

;; NOTE Move your cursor over a module's name (or its flags) and press 'K' (or
;;      'C-c c k' for non-vim users) to view its documentation. This works on
;;      flags as well (those symbols that start with a plus).
;;
;;      Alternatively, press 'gd' (or 'C-c c d') on a module to browse its
;;      directory (for easy access to its source code).

(doom! :input
       ;;bidi              ; (tfel ot) thgir etirw uoy gnipleh
       ;;chinese
       ;;japanese
       ;;layout            ; auie,ctsrnm is the superior home row

       :completion
       ;;company           ; the ultimate code completion backend
       (corfu +orderless
              +icons
              +childframe)  ; complete with cap(f), cape and a flying feather!
       ;;helm              ; the *other* search engine for love and life
       ;;ido               ; the other *other* search engine...
       ;;ivy               ; a search engine for love and life
       (vertico +icons)           ; the search engine of the future

       :ui
       ;;deft              ; notational velocity for Emacs
       doom              ; what makes DOOM look the way it does
       doom-dashboard    ; a nifty splash screen for Emacs
       doom-quit         ; DOOM quit-message prompts when you quit Emacs
       ;;(emoji +unicode)  ; 🙂
       hl-todo           ; highlight TODO/FIXME/NOTE/DEPRECATED/HACK/REVIEW
       indent-guides     ; highlighted indent columns
       (ligatures +extra)         ; ligatures and symbols to make your code pretty again
       ;;minimap           ; show a map of the code on the side
       modeline          ; snazzy, Atom-inspired modeline, plus API
       ;;nav-flash         ; blink cursor line after big motions
       ;;neotree           ; a project drawer, like NERDTree for vim
       ophints           ; highlight the region an operation acts on
       (popup +defaults)   ; tame sudden yet inevitable temporary windows
       (smooth-scroll +interpolate)     ; So smooth you won't believe it's not butter
       ;; tabs              ; a tab bar for Emacs
       ;;treemacs          ; a project drawer, like neotree but cooler
       ;;unicode           ; extended unicode support for various languages
       (vc-gutter +pretty) ; vcs diff in the fringe
       vi-tilde-fringe   ; fringe tildes to mark beyond EOB
       window-select     ; visually switch windows
       workspaces       ; tab emulation, persistence & separate workspaces
       zen               ; distraction-free coding or writing

       :editor
       ;; (evil +everywhere); come to the dark side, we have cookies
       (meow +qwerty)
       file-templates    ; auto-snippets for empty files
       fold              ; (nigh) universal code folding
       (format +onsave)  ; automated prettiness
       ;;god               ; run Emacs commands without modifier keys
       ;;lispy             ; vim for lisp, for people who don't like vim
       ;;multiple-cursors  ; editing in many places at once
       ;;objed             ; text object editing for the innocent
       ;;parinfer          ; turn lisp into python, sort of
       rotate-text       ; cycle region at point between text candidates
       snippets          ; my elves. They type so I don't have to
       word-wrap         ; soft wrapping with language-aware indent

       :emacs
       (dired +icons
              +dirvish)             ; making dired pretty [functional]
       electric          ; smarter, keyword-based electric-indent
       ;;eww               ; the internet is gross
       (ibuffer +icons)           ; interactive buffer management
       undo              ; persistent, smarter undo for your inevitable mistakes
       vc                ; version-control and Emacs, sitting in a tree

       :term
       eshell            ; the elisp shell that works everywhere
       ;;shell             ; simple shell REPL for Emacs
       ;;term              ; basic terminal emulator for Emacs
       ;;vterm             ; the best terminal emulation in Emacs

       :checkers
       (syntax +childframe
               +icons)              ; tasing you for every semicolon you forget
       (spell +flyspell) ; tasing you for misspelling mispelling
       grammar           ; tasing grammar mistake every you make

       :tools
       ;;ansible
       biblio            ; Writes a PhD for you (citation needed)
       ;;collab            ; buffers with friends
       ;;debugger          ; FIXME stepping through code, to help you add bugs
       direnv
       ;;docker
       ;;editorconfig      ; let someone else argue about tabs vs spaces
       ;;ein               ; tame Jupyter notebooks with emacs
       (eval +overlay)     ; run code, run (also, repls)
       lookup              ; navigate your code and its documentation
       lsp               ; M-x vscode
       (magit +icons
              +forge)             ; a git porcelain for Emacs
       ;;make              ; run make tasks from Emacs
       ;;pass              ; password manager for nerds
       pdf               ; pdf enhancements
       ;;terraform         ; infrastructure as code
       ;;tmux              ; an API for interacting with tmux
       tree-sitter       ; syntax and parsing, sitting in a tree...
       upload            ; map local to remote projects via ssh/ftp

       :os
       (:if (featurep :system 'macos) macos)  ; improve compatibility with macOS
       ;;tty               ; improve the terminal Emacs experience

       :lang
       ;;agda              ; types of types of types of types...
       ;;beancount         ; mind the GAAP
       ;;(cc +lsp)         ; C > C++ == 1
       ;;clojure           ; java with a lisp
       ;;common-lisp       ; if you've seen one lisp, you've seen them all
       ;;coq               ; proofs-as-programs
       ;;crystal           ; ruby at the speed of c
       ;;csharp            ; unity, .NET, and mono shenanigans
       data              ; config/data formats
       ;;(dart +flutter)   ; paint ui and not much else
       ;;dhall
       ;;elixir            ; erlang done right
       ;;elm               ; care for a cup of TEA?
       emacs-lisp        ; drown in parentheses
       ;;erlang            ; an elegant language for a more civilized age
       ;;ess               ; emacs speaks statistics
       ;;factor
       ;;faust             ; dsp, but you get to keep your soul
       ;;fortran           ; in FORTRAN, GOD is REAL (unless declared INTEGER)
       ;;fsharp            ; ML stands for Microsoft's Language
       ;;fstar             ; (dependent) types and (monadic) effects and Z3
       ;;gdscript          ; the language you waited for
       ;;(go +lsp)         ; the hipster dialect
       ;;(graphql +lsp)    ; Give queries a REST
       ;;(haskell +lsp)    ; a language that's lazier than I am
       ;;hy                ; readability of scheme w/ speed of python
       ;;idris             ; a language you can depend on
       ;;json              ; At least it ain't XML
       ;;(java +lsp)       ; the poster child for carpal tunnel syndrome
       ;;javascript        ; all(hope(abandon(ye(who(enter(here))))))
       ;;julia             ; a better, faster MATLAB
       ;;kotlin            ; a better, slicker Java(Script)
       latex             ; writing papers in Emacs has never been so fun
       ;;lean              ; for folks with too much to prove
       ;;ledger            ; be audit you can be
       ;;lua               ; one-based indices? one-based indices
       markdown          ; writing docs for people to ignore
       ;;nim               ; python + lisp at the speed of c
       (nix +tree-sitter
            +lsp)               ; I hereby declare "nix geht mehr!"
       ;;ocaml             ; an objective camel
       (org +noter
            +pretty
            +pomodoro)               ; organize your plain life in plain text
       ;;php               ; perl's insecure younger brother
       ;;plantuml          ; diagrams for confusing people more
       ;;graphviz          ; diagrams for confusing yourself even more
       ;;purescript        ; javascript, but functional
       python            ; beautiful is better than ugly
       ;;qt                ; the 'cutest' gui framework ever
       ;;racket            ; a DSL for DSLs
       ;;raku              ; the artist formerly known as perl6
       ;;rest              ; Emacs as a REST client
       ;;rst               ; ReST in peace
       ;;(ruby +rails)     ; 1.step {|i| p "Ruby is #{i.even? ? 'love' : 'life'}"}
       ;;(rust +lsp)       ; Fe2O3.unwrap().unwrap().unwrap().unwrap()
       ;;scala             ; java, but good
       ;;(scheme +guile)   ; a fully conniving family of lisps
       sh                ; she sells {ba,z,fi}sh shells on the C xor
       ;;sml
       ;;solidity          ; do you need a blockchain? No.
       ;;swift             ; who asked for emoji variables?
       ;;terra             ; Earth and Moon in alignment for performance.
       ;;web               ; the tubes
       ;;yaml              ; JSON, but readable
       ;;zig               ; C, but simpler

       :email
       ;;(mu4e +org +gmail)
       ;;notmuch
       ;;(wanderlust +gmail)

       :app
       calendar
       ;;emms
       ;;everywhere        ; *leave* Emacs!? You must be joking
       ;;irc               ; how neckbeards socialize
       ;;(rss +org)        ; emacs as an RSS reader

       :config
       literate
       (default +bindings +smartparens))

#+end_src
** Config
#+begin_src emacs-lisp :tangle yes
;;; -*- lexical-binding: t; -*-

;; Place your private configuration here! Remember, you do not need to run 'doom
;; sync' after modifying this file!




;; Whenever you reconfigure a package, make sure to wrap your config in an
;; `after!' block, otherwise Doom's defaults may override your settings. E.g.
;;
;;   (after! PACKAGE
;;     (setq x y))
;;
;; The exceptions to this rule:
;;
;;   - Setting file/directory variables (like `org-directory')
;;   - Setting variables which explicitly tell you to set them before their
;;     package is loaded (see 'C-h v VARIABLE' to look up their documentation).
;;   - Setting doom variables (which start with 'doom-' or '+').
;;
;; Here are some additional functions/macros that will help you configure Doom.
;;
;; - `load!' for loading external *.el files relative to this one
;; - `use-package!' for configuring packages
;; - `after!' for running code after a package has loaded
;; - `add-load-path!' for adding directories to the `load-path', relative to
;;   this file. Emacs searches the `load-path' when you load packages with
;;   `require' or `use-package'.
;; - `map!' for binding new keys
;;
;; To get information about any of these functions/macros, move the cursor over
;; the highlighted symbol at press 'K' (non-evil users must press 'C-c c k').
;; This will open documentation for it, including demos of how they are used.
;; Alternatively, use `C-h o' to look up a symbol (functions, variables, faces,
;; etc).
;;
;; You can also try 'gd' (or 'C-c c d') to jump to their definition and see how
;; they are implemented.
#+end_src
** Package
#+begin_src emacs-lisp :tangle yes
;; -*- no-byte-compile: t; -*-
;;; $DOOMDIR/packages.el

;; To install a package with Doom you must declare them here and run 'doom sync'
;; on the command line, then restart Emacs for the changes to take effect -- or


;; To install SOME-PACKAGE from MELPA, ELPA or emacsmirror:
;; (package! some-package)

;; To install a package directly from a remote git repo, you must specify a
;; `:recipe'. You'll find documentation on what `:recipe' accepts here:
;; https://github.com/radian-software/straight.el#the-recipe-format
;; (package! another-package
;;   :recipe (:host github :repo "username/repo"))

;; If the package you are trying to install does not contain a PACKAGENAME.el
;; file, or is located in a subdirectory of the repo, you'll need to specify
;; `:files' in the `:recipe':
;; (package! this-package
;;   :recipe (:host github :repo "username/repo"
;;            :files ("some-file.el" "src/lisp/*.el")))

;; If you'd like to disable a package included with Doom, you can do so here
;; with the `:disable' property:
;; (package! builtin-package :disable t)

;; You can override the recipe of a built in package without having to specify
;; all the properties for `:recipe'. These will inherit the rest of its recipe
;; from Doom or MELPA/ELPA/Emacsmirror:
;; (package! builtin-package :recipe (:nonrecursive t))
;; (package! builtin-package-2 :recipe (:repo "myfork/package"))

;; Specify a `:branch' to install a package from a particular branch or tag.
;; This is required for some packages whose default branch isn't 'master' (which
;; our package manager can't deal with; see radian-software/straight.el#279)
;; (package! builtin-package :recipe (:branch "develop"))

;; Use `:pin' to specify a particular commit to install.
;; (package! builtin-package :pin "1a2b3c4d5e")


;; Doom's packages are pinned to a specific commit and updated from release to
;; release. The `unpin!' macro allows you to unpin single packages...
;; (unpin! pinned-package)
;; ...or multiple packages
;; (unpin! pinned-package another-pinned-package)
;; ...Or *all* packages (NOT RECOMMENDED; will likely break things)
;; (unpin! t)
#+end_src
* Input
* Completion
* UI
** Doom Dashboard
*** Set splash image and randomize
#+begin_src emacs-lisp :tangle yes
(setq +fancy-splash-image-directory (expand-file-name "assets/splash-images/" doom-user-dir))

(defun +doom-dashboard-randomize-splash ()
  (interactive)
  (setq fancy-splash-image (let ((splash-images (directory-files +fancy-splash-image-directory t "^[^.].*")))
                           (nth (random (length splash-images)) splash-images))))
#+end_src

*** Minimal dashboard
#+begin_src emacs-lisp :tangle yes
(defun +doom-dashboard-tweak (&optional _)
  ;; (with-current-buffer (get-buffer +doom-dashboard-name)
    (setq-local line-spacing 0.2
                mode-line-format nil
                mode-name ""
                cursor-type nil
                visible-cursor nil
                ;; meow-cursor-type-region-cursor nil
                ;; hl-line-mode 0
                )
    (hl-line-mode 0)
    ;; )
)

;; (add-hook! '+doom-dashboard-mode-hook #'+doom-dashboard-tweak)
;; (custom-set-faces! '(doom-dashboard-footer :inherit font-lock-doc-face))
;; (add-hook! 'doom-after-init-hook #'+doom-dashboard-tweak)
;; (add-hook! '+doom-dashboard-functions #'+doom-dashboard-tweak)
#+end_src

*** Dashboard keybindings :keybindings:
#+begin_src emacs-lisp :tangle yes
(defun +doom-dashboard-setup-modified-keymap ()
  (setq +doom-dashboard-mode-map (make-sparse-keymap))
  (map! :map +doom-dashboard-mode-map
        :desc "Agenda" "a" #'org-agenda
        :desc "Agenda (GTD)" "A" (cmd! (org-agenda nil "g"))
        :desc "Capture" "N" #'org-capture
        :desc "Scratch Buffer" "x" #'doom/switch-to-scratch-buffer
        :desc "Find file" "f" #'find-file
        :desc "Recent files" "r" #'consult-recent-file
        :desc "Restore session" "R" #'doom/quickload-session
        :desc "Config dir" "C" #'doom/open-private-config
        :desc "Open config.org" "c" (cmd! (find-file (expand-file-name "config.org" doom-user-dir)))
        ;; :desc "Open org-mode root"  "O" (cmd! (find-file (expand-file-name "lisp/org/" doom-user-dir)))
        :desc "Open dotfile" "." (cmd! (doom-project-find-file "~/.config/"))
        :desc "Notes" "n" #'denote-open-or-create
        :desc "Switch buffer" "b" #'+vertico/switch-workspace-buffer
        :desc "Switch buffers (all)" "B" #'consult-buffer
        :desc "Open bookmarks" "RET" #'bookmark-jump
        :desc "Doom documentation" "H" #'doom/help
        :desc "Today's Journal" "J" #'denote-journal-new-or-existing-entry
        :desc "IBuffer" "i" #'ibuffer
        ;; :desc "Previous buffer" "p" #'previous-buffer
        :desc "Set theme" "t" #'consult-theme
        :desc "Quit" "Q" #'save-buffers-kill-terminal
        :desc "Open project" "p" #' projectile-switch-project
        :desc "Show keybindings" "h" (cmd! (which-key-show-keymap '+doom-dashboard-mode-map))))

(add-transient-hook! #'+doom-dashboard-mode (+doom-dashboard-setup-modified-keymap))
(add-transient-hook! #'+doom-dashboard-mode :append (+doom-dashboard-setup-modified-keymap))
(add-hook! 'doom-init-ui-hook :append (+doom-dashboard-setup-modified-keymap))
#+end_src

*** Leader keybinding to dashboard :keybinding:
#+begin_src emacs-lisp :tangle yes
(map! :map doom-leader-open-map
      "d" #'+doom-dashboard/open)
#+end_src

*** Add splash phrases
Taken from https://tecosaur.github.io/emacs-config/config.html
#+begin_src emacs-lisp :tangle yes
(defvar splash-phrase-source-folder
  (expand-file-name "assets/splash-phrases" doom-user-dir)
  "A folder of text files with a fun phrase on each line.")


(defvar splash-phrase-sources
  (let* ((files (directory-files splash-phrase-source-folder nil "\\.txt\\'"))
         (sets (delete-dups (mapcar
                             (lambda (file)
                               (replace-regexp-in-string "\\(?:-[0-9]+-\\w+\\)?\\.txt" "" file))
                             files))))
    (mapcar (lambda (sset)
              (cons sset
                    (delq nil (mapcar
                               (lambda (file)
                                 (when (string-match-p (regexp-quote sset) file)
                                   file))
                               files))))
            sets))
  "A list of cons giving the phrase set name, and a list of files which contain phrase components.")

(defvar splash-phrase-set
  (nth (random (length splash-phrase-sources)) (mapcar #'car splash-phrase-sources))
  "The default phrase set. See `splash-phrase-sources'.")


(defun splash-phrase-set-random-set ()
  "Set a new random splash phrase set."
  (interactive)
  (setq splash-phrase-set
        (nth (random (1- (length splash-phrase-sources)))
             (cl-set-difference (mapcar #'car splash-phrase-sources) (list splash-phrase-set))))
  (+doom-dashboard-reload t))

(defun splash-phrase-select-set ()
  "Select a specific splash phrase set."
  (interactive)
  (setq splash-phrase-set (completing-read "Phrase set: " (mapcar #'car splash-phrase-sources)))
  (+doom-dashboard-reload t))

(defvar splash-phrase--cached-lines nil)

(defun splash-phrase-get-from-file (file)
  "Fetch a random line from FILE."
  (let ((lines (or (cdr (assoc file splash-phrase--cached-lines))
                   (cdar (push (cons file
                                     (with-temp-buffer
                                       (insert-file-contents (expand-file-name file splash-phrase-source-folder))
                                       (split-string (string-trim (buffer-string)) "\n")))
                               splash-phrase--cached-lines)))))
    (nth (random (length lines)) lines)))

(defun splash-phrase (&optional set)
  "Construct a splash phrase from SET. See `splash-phrase-sources'."
  (mapconcat
   #'splash-phrase-get-from-file
   (cdr (assoc (or set splash-phrase-set) splash-phrase-sources))
   " "))


(defun splash-phrase-dashboard-formatted ()
  "Get a splash phrase, flow it over multiple lines as needed, and fontify it."
  (mapconcat
   (lambda (line)
     (+doom-dashboard--center
      +doom-dashboard--width
      (with-temp-buffer
        ;; (insert-text-button
         (insert (propertize line 'face '(:inherit doom-dashboard-menu-title :slant italic)))
         ;; 'action
         ;; (lambda (_) (+doom-dashboard-reload t))
         ;; 'face '(:inherit doom-dashboard-menu-title :slant italic)
         ;; 'mouse-face 'doom-dashboard-menu-title
         ;; 'help-echo "Random phrase"
         ;; 'follow-link t)
        (buffer-string)
        )))
   (split-string
    (with-temp-buffer
      (insert (splash-phrase))
      (setq fill-column (min 70 (/ (* 2 (window-width)) 3)))
      (fill-region (point-min) (point-max))
      (buffer-string))
    "\n"
    )
   "\n"
   ))
(add-hook! '+doom-dashboard-functions :append #'splash-phrase-dashboard-formatted)

(defun splash-phrase-dashboard-insert ()
  "Insert the splash phrase surrounded by newlines."
  (insert "\n" (splash-phrase-dashboard-formatted) "\n"))

(defun +doom-dashboard-flower ()
  "Flower"
  (insert
   "\n"
   (+doom-dashboard--center
    (- +doom-dashboard--width 2)
    (with-temp-buffer
      (insert
       (propertize "🌸" 'face '(:height 200)))
      (buffer-string)))))
(add-hook! '+doom-dashboard-functions :append #'+doom-dashboard-flower)
#+end_src

*** Adjust doom-dashboard functions
#+begin_src emacs-lisp :tangle yes
(setq +doom-dashboard-functions
      (list #'+doom-dashboard-tweak
            #'+doom-dashboard-randomize-splash
            #'doom-dashboard-widget-banner
            #'doom-dashboard-widget-loaded
            #'splash-phrase-dashboard-insert
            #'+doom-dashboard-flower
            ))

#+end_src


** Modeline :builtin:
*** Show wordcount in modeline :appearance:
#+begin_src emacs-lisp :tangle yes
(after! doom-modeline
  (setq doom-modeline-enable-word-count t))
#+end_src
*** Show mode icon in modeline :appearance:
#+begin_src emacs-lisp :tangle yes
(after! doom-modeline
  (setq doom-modeline-major-mode-icon t))
#+end_src
** Indent-guides
*** Make indent-guides straight lines
#+begin_src emacs-lisp :tangle yes
(after! indent-bars
  (setq indent-bars-pattern "."))
#+end_src
** Theme
#+begin_src emacs-lisp :tangle yes
;; There are two ways to load a theme. Both assume the theme is installed and
;; available. You can either set `doom-theme' or manually load a theme with the
;; `load-theme' function. This is the default:
(setq doom-theme 'catppuccin)

#+end_src
*** Modus
#+begin_src emacs-lisp :tangle packages.el
(package! modus-themes)
#+end_src

#+begin_src emacs-lisp :tangle yes
(use-package! modus-themes
  :defer t)
#+end_src
*** Catppuccin
#+begin_src emacs-lisp :tangle packages.el
(package! catppuccin-theme)
#+end_src

#+begin_src emacs-lisp :tangle yes
(use-package! catppuccin-theme
  :defer t)
#+end_src
*** Ef-themes
#+begin_src emacs-lisp :tangle packages.el
(package! ef-themes)
#+end_src

#+begin_src emacs-lisp :tangle yes
(use-package! ef-themes
  :defer t)
#+end_src
** Spacious Padding
#+begin_src emacs-lisp :tangle packages.el
(package! spacious-padding)
#+end_src

#+begin_src emacs-lisp :tangle yes
(use-package! spacious-padding
  :hook (doom-init-ui . spacious-padding-mode)
  :init
  (setq spacious-padding-subtle-mode-line t
        spacious-padding-widths '(:internal-border-width 15
                             :right-divider-width 20
                             :header-line-width 4
                             :mode-line-width 1
                             :tab-width 3
                             :scroll-bar-width 8
                             :left-fringe-width 8
                             :right-fringe-width 13)))
#+end_src
** Pulsar
#+begin_src emacs-lisp :tangle packages.el
(package! pulsar)
#+end_src

#+begin_src emacs-lisp :tangle yes
(use-package! pulsar
    :hook (doom-first-input . pulsar-global-mode))
#+end_src
** Olivetti
#+begin_src emacs-lisp :tangle packages.el
(package! olivetti)
#+end_src

#+begin_src emacs-lisp :tangle yes
(use-package! olivetti
  :custom
  (olivetti-style 'fancy)
  :hook
  ((org-mode . olivetti-mode)
   (markdown-mode . olivetti-mode)
   (org-agenda-mode . olivetti-mode))
  :init
  ;; need to set early
  (setq olivetti-body-width 122
        mode-line-right-align-edge 'right-margin))
#+end_src

*** Use mixed-pitch in modes with olivetti :ui:
#+begin_src emacs-lisp :tangle yes
(after! mixed-pitch-mode
  (add-hook! olivetti-mode #'mixed-pitch-mode))
#+end_src
** Info-Colors
#+begin_src emacs-lisp :tangle packages.el
(package! info-colors)
#+end_src

#+begin_src emacs-lisp :tangle yes
(use-package! info-colors
  :hook (Info-selection . info-colors-fontify-node))
#+end_src
** HL-todo
*** Consult-todo
#+begin_src emacs-lisp :tangle packages.el
(package! consult-todo)
#+end_src

#+begin_src emacs-lisp :tangle yes
(use-package! consult-todo
  :after (consult hl-todo))
#+end_src

* Editor
** Line Numbers
#+begin_src emacs-lisp :tangle yes
;; This determines the style of line numbers in effect. If set to `nil', line
;; numbers are disabled. For relative line numbers, set this to `relative'.
(setq display-line-numbers-type t)
#+end_src
** Buffer
#+begin_src emacs-lisp :tangle yes
(map! :leader (:prefix-map ("b" . "buffer")
       :desc "Toggle narrowing"            "-"   #'doom/toggle-narrow-buffer
       :desc "Previous buffer"             "["   #'previous-buffer
       :desc "Next buffer"                 "]"   #'next-buffer
       (:when (modulep! :ui workspaces)
        :desc "Switch workspace buffer" "b" #'persp-switch-to-buffer
        :desc "Switch buffer"           "B" #'switch-to-buffer
        :desc "ibuffer workspace"       "I" #'+ibuffer/open-for-current-workspace)
       (:unless (modulep! :ui workspaces)
        :desc "Switch buffer"           "b" #'switch-to-buffer)
       :desc "Clone buffer"                "c"   #'clone-indirect-buffer
       :desc "Clone buffer other window"   "C"   #'clone-indirect-buffer-other-window
       :desc "Kill buffer"                 "d"   #'kill-current-buffer
       :desc "ibuffer"                     "i"   #'ibuffer
       :desc "Kill buffer"                 "k"   #'kill-current-buffer
       :desc "Kill all buffers"            "K"   #'doom/kill-all-buffers
       (:when (modulep! :editor meow)
         :desc "Switch to last buffer"       "l"   #'meow-last-buffer)
       :desc "Set bookmark"                "m"   #'bookmark-set
       :desc "Delete bookmark"             "M"   #'bookmark-delete
       :desc "Next buffer"                 "n"   #'next-buffer
       ;; :desc "New empty buffer"            "N"   #'evil-buffer-new
       :desc "Kill other buffers"          "O"   #'doom/kill-other-buffers
       :desc "Previous buffer"             "p"   #'previous-buffer
       :desc "Revert buffer"               "r"   #'revert-buffer
       :desc "Rename buffer"               "R"   #'rename-buffer
       :desc "Save buffer"                 "s"   #'basic-save-buffer
       ;; :desc "Save all buffers"            "S"   #'evil-write-all
       :desc "Save buffer as root"         "u"   #'doom/sudo-save-buffer
       :desc "Pop up scratch buffer"       "x"   #'doom/open-scratch-buffer
       :desc "Switch to scratch buffer"    "X"   #'doom/switch-to-scratch-buffer
       :desc "Yank buffer"                 "y"   #'+default/yank-buffer-contents
       :desc "Bury buffer"                 "z"   #'bury-buffer
       :desc "Kill buried buffers"         "Z"   #'doom/kill-buried-buffers))
#+end_src
** Font
#+begin_src emacs-lisp :tangle yes
;; Doom exposes five (optional) variables for controlling fonts in Doom:
;;
;; - `doom-font' -- the primary font to use
;; - `doom-variable-pitch-font' -- a non-monospace font (where applicable)
;; - `doom-big-font' -- used for `doom-big-font-mode'; use this for
;;   presentations or streaming.
;; - `doom-symbol-font' -- for symbols
;; - `doom-serif-font' -- for the `fixed-pitch-serif' face
;;
;; See 'C-h v doom-font' for documentation and more examples of what they
;; accept. For example:
;;
(setq doom-font (font-spec :family "Maple Mono NF" :size 13)
     doom-variable-pitch-font (font-spec :family "Maple Mono NF" :size 13)
     doom-symbol-font (font-spec :family "JuliaMono" :size 13))
;;
;; If you or Emacs can't find your font, use 'M-x describe-font' to look them
;; up, `M-x eval-region' to execute elisp code, and 'M-x doom/reload-font' to
;; refresh your font settings. If Emacs still can't find your font, it likely
;; wasn't installed correctly. Font issues are rarely Doom issues!
#+end_src

** Files
*** Save keybindings
#+begin_src emacs-lisp :tangle yes
(map! :leader (:prefix-map ("f" . "file")
      :desc "Save file"                   "s"   #'save-buffer
      :desc "Save file as..."             "S"   #'write-file))
#+end_src
*** Delete by moving to trash
#+begin_src emacs-lisp :tangle yes
(setq-default delete-by-moving-to-trash t)
#+end_src
*** Make backups
#+begin_src emacs-lisp :tangle yes
(setq-default make-backup-files t
              version-control t
              delete-old-versions t
              create-lockfiles nil)
#+end_src

** Meow
Set some defaults
#+begin_src emacs-lisp :tangle yes
(after! meow
  (setq meow-use-clipboard t
        meow-use-enhanced-selection-effect t)
  (after! consult
    (setq meow-goto-line-function 'consult-goto-line)))
#+end_src
*** Normal mode tweaks
#+begin_src emacs-lisp :tangle yes
(after! meow
  (meow-normal-define-key
 '("d" . meow-kill)
 '("g" . "M-g")
 '("M" . join-line)
 '("s" . avy-goto-char-2)
 '("S" . embrace-commander)
 '("u" . undo-fu-only-undo)
 '("U" . undo-fu-only-redo)
 '("/" . meow-visit)
 '("?" . meow-query-replace-regexp)))
#+end_src
*** Motion mode tweaks
#+begin_src emacs-lisp :tangle yes
(after! meow
  (meow-motion-define-key
   '("j" . "C-n")
   '("k" . "C-p")))
#+end_src

*** Leader keys
Add some keys from doom evil mode back into meow's leader keymap
#+begin_src emacs-lisp :tangle yes
(after! meow
  (meow-leader-define-key
   '("." . find-file)
   '("," . persp-switch-to-buffer)
   '("~" . +popup/toggle)
   '("<" . switch-to-buffer)
   '("'" . vertico-repeat)
   '("*" . +default/search-project-for-symbol-at-point)
   '("/" . +default/search-project)
   '("SPC" . projectile-find-file)
   '("RET" . bookmark-jump)
   '(";" . pp-eval-expression)
   '(":" . execute-extended-command)
   ;; (cons "TAB" persp-key-map)
   (cons "w" window-prefix-map)))
#+end_src

*** Automatic =meow-insert= hooks
Automatically switch to =meow-insert= mode for convenience.
#+begin_src emacs-lisp :tangle yes
(after! org
    ;; Change to insert mode after certain org functions
    (add-hook 'org-insert-heading-hook 'meow-insert)
    ;; TODO check if src buffer is empty before switching to insert mode
    (add-hook 'org-src-mode-hook 'meow-insert)
    (add-hook 'org-capture-mode-hook 'meow-insert)
    (add-hook 'org-log-buffer-setup-hook 'meow-insert)
    (add-hook 'org-metareturn-hook 'meow-insert))
#+end_src

#+begin_src emacs-lisp :tangle yes
(after! git-commit
    (add-hook
     'git-commit-mode-hook
     (defun +meow--git-commit-insert-mode ()
       (when (bound-and-true-p meow-mode) (meow-insert-mode 1)))))
#+end_src
*** Meow Tree-sitter
Add tree-sitter support to meow.
#+begin_src emacs-lisp :tangle packages.el
(package! meow-tree-sitter)
#+end_src

#+begin_src emacs-lisp :tangle yes
(use-package! meow-tree-sitter
  :after (meow treesit)
  :init
  (meow-tree-sitter-register-defaults))
#+end_src
*** HACK Restore =helpful-describe-key=
Meow for some reason overrides the mapping of =helpful-describe-key=. This restores that functionality.
#+begin_src emacs-lisp :tangle yes
(after! meow
  (after! helpful
    (map! [remap meow-describe-key] #'helpful-key)))
#+end_src
*** Have =meow-kill= fall back on =meow-C-d=
#+begin_src emacs-lisp :tangle yes
(after! meow
  (setq meow-selection-command-fallback '((meow-change . meow-change-char)
 (meow-kill . meow-C-d)
 (meow-cancel-selection . keyboard-quit)
 (meow-pop-selection . meow-pop-grab)
 (meow-beacon-change . meow-beacon-change-char))))
#+end_src
*** Shims
**** Org
***** Better =org-return=
#+begin_src emacs-lisp :tangle yes
(defun +my/org-return-dwim (&optional ARG)
  (interactive)
      (if (eq (meow--current-state) 'normal)
          (+org/dwim-at-point ARG)
          (scimax/org-return ARG)
        ;; (+org/return)
        ))
#+end_src

#+begin_src emacs-lisp :tangle yes
(after! (:and meow org)
  (map! :map org-mode-map
        "RET" #'+my/org-return-dwim
        [return] #'+my/org-return-dwim))
#+end_src
*** Preselect visit
#+begin_src emacs-lisp :tangle yes
(after! vertico-multiform
    (add-to-list 'vertico-multiform-commands '(meow-visit (vertico-preselect . prompt))))
#+end_src
*** Mode states
Set meow's initial mode for various major modes
#+begin_src emacs-lisp :tangle yes
(after! meow
  (add-to-list 'meow-mode-state-list '((eat-mode . insert))))
#+end_src

** Embrace

#+begin_src emacs-lisp :tangle packages.el
(package! embrace)
#+end_src

#+begin_src emacs-lisp :tangle yes
(use-package! embrace
  :commands embrace-commander
  :hook (LaTex-mode . embrace-LaTex-mode-hook)
  ;; :hook (org-mode . embrace-org-mode-hook)
  :hook (ruby-mode . embrace-ruby-mode-hook)
  :hook (emacs-lisp-mode . embrace-emacs-lisp-mode-hook))
#+end_src
** COMMENT Surround

#+begin_src emacs-lisp :tangle packages.el
(package! surround)
#+end_src

#+begin_src emacs-lisp :tangle yes
(use-package! surround
  :defer t)
#+end_src

** COMMENT Dogears
#+begin_src emacs-lisp :tangle packages.el
(package! dogears)
#+end_src

#+begin_src emacs-lisp :tangle yes
(use-package! dogears
  :hook (doom-first-buffer . dogears-mode)
  :bind (;; ("M-g d" . dogears-go)
         ("M-g M-d" . dogears-list)
         ("M-g M-b" . dogears-back)
         ("M-g M-f" . dogears-forward)
         ))
#+end_src

** Casual
#+begin_src emacs-lisp :tangle packages.el
(package! casual-suite)
#+end_src

#+begin_src elisp
(use-package! casual-suite
  :bind
  (("M-g a" . #'casual-avy-tmenu))
  :config
  (setq casual-lib-use-unicode t))
#+end_src
** Which Key
*** Show =which-key= buffer sooner
#+begin_src emacs-lisp :tangle yes
(after! which-key
  (setq which-key-idle-delay 0.3))
#+end_src
** Windows
#+begin_src emacs-lisp :tangle yes
(map! :leader
      (:prefix-map ("w" . "window")
       :desc "Undo window config"           "u" #'winner-undo
       :desc "Redo window config"           "U" #'winner-redo
       "d" #'delete-window
       "D" #'delete-other-windows
       "s" #'split-window-below
       "S" #'split-window-below
       "v" #'split-window-right
       "+" #'enlarge-window
       "=" #'balance-windows
       "-" #'shrink-window
       "+" #'enlarge-window
       "<" #'shrink-window-horizontally
       ">" #'enlarge-window-horizontally
       "h" #'windmove-left
       "j" #'windmove-down
       "k" #'windmove-up
       "l" #'windmove-right
       "H" #'windmove-swap-states-left
       "J" #'windmove-swap-states-down
       "K" #'windmove-swap-states-up
       "L" #'windmove-swap-states-right
       "o" #'delete-other-windows
       "n" #'next-window-any-frame
       "p" #'previous-window-any-frame
       "w" #'other-window))
#+end_src


*** Transpose Frame
#+begin_src emacs-lisp :tangle packages.el
(package! transpose-frame)
#+end_src

#+begin_src emacs-lisp :tangle yes
(map! :leader
      (:prefix-map ("w" . "window")
        "t" #'transpose-frame
        "f" #'flip-frame
        "F" #'flop-frame
        "r" #'rotate-frame-clockwise
        "R" #'rotate-frame-anticlockwise))
#+end_src

** Workspace
#+begin_src emacs-lisp :tangle no
(package! tabspaces)
#+end_src

#+begin_src emacs-lisp :tangle no
(use-package tabspaces
  ;; use this next line only if you also use straight, otherwise ignore it.
  :hook (doom-init-ui . tabspaces-mode) ;; use this only if you want the minor-mode loaded at startup.
  :commands (tabspaces-switch-or-create-workspace
             tabspaces-open-or-create-project-and-workspace)
  :bind
  (:map tabspaces-mode-map
        ("C-c TAB TAB" . #'tabspaces-switch-or-create-workspace))
  :custom
  (tabspaces-use-filtered-buffers-as-default t)
  (tabspaces-default-tab "Default")
  (tabspaces-remove-to-default t)
  ;; (tabspaces-include-buffers '("*scratch*" "*dashboard*"))
  ;; (tabspaces-initialize-project-with-todo t)
  ;; (tabspaces-todo-file-name "project-todo.org")
  ;; sessions
  ;; (tabspaces-session t)
  ;; (tabspaces-session-auto-restore t)
  :config
  (with-eval-after-load 'consult
    ;; hide full buffer list (still available with "b" prefix)
    (consult-customize consult--source-buffer :hidden t :default nil)
    ;; set consult-workspace buffer list
    (defvar consult--source-workspace
      (list :name     "Workspace Buffers"
            :narrow   ?w
            :history  'buffer-name-history
            :category 'buffer
            :state    #'consult--buffer-state
            :default  t
            :items    (lambda () (consult--buffer-query
                                  :predicate #'tabspaces--local-buffer-p
                                  :sort 'visibility
                                  :as #'buffer-name)))

      "Set workspace buffer list for consult-buffer.")
    (add-to-list 'consult-buffer-sources 'consult--source-workspace))
  ;; Rename the first tab to `tabspaces-default-tab'
  ;; (tab-bar-rename-tab tabspaces-default-tab)
  )
#+end_src
#+begin_src emacs-lisp :tangle yes
(map! :leader (:when (modulep! :ui workspaces)
       (:prefix-map ("TAB" . "workspace")
        :desc "Display tab bar"           "TAB" #'+workspace/display
        :desc "Switch workspace"          "."   #'+workspace/switch-to
        :desc "Switch to last workspace"  "`"   #'+workspace/other
        :desc "New workspace"             "n"   #'+workspace/new
        :desc "New named workspace"       "N"   #'+workspace/new-named
        :desc "Load workspace from file"  "l"   #'+workspace/load
        :desc "Save workspace to file"    "s"   #'+workspace/save
        :desc "Kill session"              "x"   #'+workspace/kill-session
        :desc "Kill this workspace"       "d"   #'+workspace/kill
        :desc "Delete saved workspace"    "D"   #'+workspace/delete
        :desc "Rename workspace"          "r"   #'+workspace/rename
        :desc "Restore last session"      "R"   #'+workspace/restore-last-session
        :desc "Next workspace"            "]"   #'+workspace/switch-right
        :desc "Previous workspace"        "["   #'+workspace/switch-left
        :desc "Switch to 1st workspace"   "1"   #'+workspace/switch-to-0
        :desc "Switch to 2nd workspace"   "2"   #'+workspace/switch-to-1
        :desc "Switch to 3rd workspace"   "3"   #'+workspace/switch-to-2
        :desc "Switch to 4th workspace"   "4"   #'+workspace/switch-to-3
        :desc "Switch to 5th workspace"   "5"   #'+workspace/switch-to-4
        :desc "Switch to 6th workspace"   "6"   #'+workspace/switch-to-5
        :desc "Switch to 7th workspace"   "7"   #'+workspace/switch-to-6
        :desc "Switch to 8th workspace"   "8"   #'+workspace/switch-to-7
        :desc "Switch to 9th workspace"   "9"   #'+workspace/switch-to-8
        :desc "Switch to final workspace" "0"   #'+workspace/switch-to-final)))
#+end_src
** COMMENT Phi Search
#+begin_src emacs-lisp :tangle packages.el
(package! phi-search)
#+end_src

#+begin_src emacs-lisp :tangle yes
(use-package! phi-search
  :bind
  (([remap isearch-forward] . #'phi-search)
   ([remap isearch-forward-regexp] . #'phi-search)
   ([remap isearch-backward] . #'phi-search-backward)
   ([remap isearch-backward-regexp] . #'phi-search-backward)
   :map phi-search-default-map
   ("<escape>" . phi-search-abort))
  :custom
  (phi-search-case-sensitive 'guess)
  :config
  ;; HACK: phi-search quits in a weird state when pressing escape. This hook ensures that it properly aborts when exiting that way.
  ;; Hook must be added when `phi-search' starts because `minibuffer-exit-hook' gets cleared after minibuffer exits.
  (add-hook 'phi-search-init-hook (lambda () (add-hook 'minibuffer-exit-hook (defun +phi-search-quit-on-escape ()
                                                                               "Execute `phi-search-abort' when pressing `<escape>'"
                                                                               (when phi-search--active (phi-search-abort)))))))
#+end_src
** Smart-parens
** Aggressive Indent

#+begin_src emacs-lisp :tangle packages.el
(package! aggressive-indent)
#+end_src

#+begin_src emacs-lisp :tangle yes
(use-package! aggressive-indent
  :hook (doom-first-file . global-aggressive-indent-mode))
#+end_src
** Repeat-Fu
#+begin_src emacs-lisp :tangle packages.el
(package! repeat-fu)
#+end_src

#+begin_src emacs-lisp :tangle yes
(use-package! repeat-fu
  :commands (repeat-fu-mode repeat-fu-execute)

  :config
  (setq repeat-fu-preset 'meow)

  :hook
  ((meow-mode)
   .
   (lambda ()
     (when (and (not (minibufferp)) (not (derived-mode-p 'special-mode)))
       (repeat-fu-mode)
       (define-key meow-normal-state-keymap (kbd "'") 'repeat-fu-execute)))))
#+end_src

* Emacs
** Undo
*** Vundo :builtin:
**** Map vundo on leader keymap :keybinding:
#+begin_src emacs-lisp :tangle yes
(after! vundo
  (map! :map doom-leader-open-map
      "u" #'vundo))
#+end_src
*** Raise Undo limit
I keep losing undo history when garbage collection happens. Raise the undo limit to prevent this.
#+begin_src emacs-lisp :tangle yes
(setq undo-limit 80000000)
#+end_src
** Dired/Dirvish
*** Dirvish keybindings

Use doom's evil keybindings for dirvish
#+begin_src emacs-lisp :tangle yes
(after! dirvish
  (map! :map dirvish-mode-map
          "?"   #'dirvish-dispatch
          "q"   #'dirvish-quit
          "b"   #'dirvish-quick-access
         "f"   #'dirvish-file-info-menu
          "p"   #'dirvish-yank
         "S"   #'dirvish-quicksort
          "F"   #'dirvish-layout-toggle
          "z"   #'dirvish-history-jump
          "gh"  #'dirvish-subtree-up
          "gl"  #'dirvish-subtree-toggle
          "h"   #'dired-up-directory
          "l"   #'dired-find-file
         [left]  #'dired-up-directory
         [right] #'dired-find-file
          "[h"  #'dirvish-history-go-backward
          "]h"  #'dirvish-history-go-forward
          "[e"  #'dirvish-emerge-next-group
          "]e"  #'dirvish-emerge-previous-group
          "TAB" #'dirvish-subtree-toggle
         "M-b" #'dirvish-history-go-backward
         "M-f" #'dirvish-history-go-forward
         "M-n" #'dirvish-narrow
         "M-" #'dirvish-mark-menu
         "M-s" #'dirvish-setup-menu
         "M-e" #'dirvish-emerge-menu
        (:prefix ("y" . "yank")
          "l"   #'dirvish-copy-file-true-path
          "n"   #'dirvish-copy-file-name
          "p"   #'dirvish-copy-file-path
          "r"   #'dirvish-copy-remote-path
          "y"   #'dired-do-copy)
        (:prefix ("s" . "symlinks")
          "s"   #'dirvish-symlink
          "S"   #'dirvish-relative-symlink
          "h"   #'dirvish-hardlink)))
#+end_src

* Term
** Eat
#+begin_src emacs-lisp :tangle packages.el
(package! eat)
#+end_src

#+begin_src emacs-lisp :tangle yes
(use-package! eat
  :custom
  (eat-kill-buffer-on-exit t)
  :hook (eshell-load . eat-eshell-mode)
  (eshell-load . eat-eshell-visual-command-mode)
  (eat-mode . goto-address-mode))
#+end_src
* Checkers
** COMMENT Jinx
#+begin_src emacs-lisp :tangle packages.el
(package! jinx)
#+end_src

#+begin_src emacs-lisp :tangle yes
;; FIXME Jinx will not compile for some reason.
(use-package! jinx
  :hook
  (doom-init-ui . global-jinx-mode)
  :config
  ;; Use my custom dictionary
  (setq jinx-languages "en_US")
  ;; Extra face(s) to ignore
  (push 'org-inline-src-block
        (alist-get 'org-mode jinx-exclude-faces))
  ;; Take over the relevant bindings.
  (after! ispell
    (global-set-key [remap ispell-word] #'jinx-correct))
  ;; I prefer for `point' to end up at the start of the word,
  ;; not just after the end.
  (advice-add 'jinx-next :after (lambda (_) (left-word)))
  (after! embark
    ;; allow spell correction via embark https://github.com/minad/jinx/discussions/213#discussioncomment-11006725
    (embark-define-overlay-target jinx category (eq %p 'jinx-overlay))
    (add-to-list 'embark-target-finders 'embark-target-jinx-at-point)
    (add-to-list 'embark-keymap-alist '(jinx jinx-repeat-map embark-general-map))
    (add-to-list 'embark-repeat-actions #'jinx-next)
    (add-to-list 'embark-repeat-actions #'jinx-previous)
    (add-to-list 'embark-target-injection-hooks (list #'jinx-correct #'embark--ignore-target)))
  )
#+end_src
* Tools
** Biblio
** Magit
*** Magit file icons
#+begin_src emacs-lisp :tangle yes
(after! magit
  (setq magit-format-file-function #'magit-format-file-nerd-icons))
#+end_src
*** Magit todos
#+begin_src emacs-lisp :tangle packages.el
(package! magit-todos)
#+end_src

#+begin_src emacs-lisp :tangle yes
(use-package! magit-todos
  :after magit
  :config
  (magit-todos-mode 1))
#+end_src
** Lookup
*** Pubmed Lookup Provider
#+begin_src emacs-lisp :tangle yes
(add-to-list '+lookup-provider-url-alist '("Pubmed" "https://pubmed.ncbi.nlm.nih.gov/?term=%s"))
#+end_src
** GPTel
#+begin_src emacs-lisp :tangle packages.el
(package! gptel :recipe (:nonrecursive t))
#+end_src

#+begin_src emacs-lisp :tangle yes
(use-package! gptel
  :config
  (setq gptel-model   'deepseek-r1:latest
      gptel-backend (gptel-make-ollama "Ollama"             ;Any name of your choosing
                                       :host "localhost:11434"               ;Where it's running
                                       :stream t                             ;Stream responses
                                       :models '(deepseek-r1:latest))
      gptel-default-mode 'org-mode))

(map! :map doom-leader-open-map "g" #'gptel)
#+end_src


** Calc
#+begin_src emacs-lisp :tangle yes
(after! calc
  (setq calc-angle-mode 'rad
        calc-symbolic-mode t))
#+end_src
* OS
* Languages
** Org
*** Editing
**** Return follows link
Pressing return follows the link
#+begin_src emacs-lisp :tangle yes
(after! org
  (setq org-return-follows-link t))
#+end_src
**** =org-return-dwim=
Better org-return adapted for doom emacs: https://github.com/alphapapa/unpackaged.el?tab=readme-ov-file#org-return-dwim
#+begin_src emacs-lisp :tangle yes
(defun unpackaged/org-element-descendant-of (type element)
  "Return non-nil if ELEMENT is a descendant of TYPE.
TYPE should be an element type, like `item' or `paragraph'.
ELEMENT should be a list like that returned by `org-element-context'."
  ;; MAYBE: Use `org-element-lineage'.
  (when-let* ((parent (org-element-property :parent element)))
    (or (eq type (car parent))
        (unpackaged/org-element-descendant-of type parent))))

;;;###autoload
(defun unpackaged/org-return-dwim (&optional default)
  "A helpful replacement for `org-return'.  With prefix, call `org-return'.

On headings, move point to position after entry content.  In
lists, insert a new item or end the list, with checkbox if
appropriate.  In tables, insert a new row or end the table."
  ;; Inspired by John Kitchin: http://kitchingroup.cheme.cmu.edu/blog/2017/04/09/A-better-return-in-org-mode/
  (interactive "P")
  (if default
      (org-return electric-indent-mode)
    (cond
     ;; Act depending on context around point.

     ;; NOTE: I prefer RET to not follow links, but by uncommenting this block, links will be
     ;; followed.

     ;; ((eq 'link (car (org-element-context)))
     ;;  ;; Link: Open it.
     ;;  (org-open-at-point-global))

     ((org-at-heading-p)
      ;; Heading: Move to position after entry content.
      ;; NOTE: This is probably the most interesting feature of this function.
      (let ((heading-start (org-entry-beginning-position)))
        (goto-char (org-entry-end-position))
        (cond ((and (org-at-heading-p)
                    (= heading-start (org-entry-beginning-position)))
               ;; Entry ends on its heading; add newline after
               (end-of-line)
               (insert "\n\n"))
              (t
               ;; Entry ends after its heading; back up
               (forward-line -1)
               (end-of-line)
               (when (org-at-heading-p)
                 ;; At the same heading
                 (forward-line)
                 (insert "\n")
                 (forward-line -1))
               ;; FIXME: looking-back is supposed to be called with more arguments.
               (while (not (looking-back (rx (repeat 3 (seq (optional blank) "\n")))))
                 (insert "\n"))
               (forward-line -1)))))

     ((org-at-item-checkbox-p)
      ;; Checkbox: Insert new item with checkbox.
      (org-insert-todo-heading nil))

     ((org-in-item-p)
      ;; Plain list.  Yes, this gets a little complicated...
      (let ((context (org-element-context)))
        (if (or (eq 'plain-list (car context))  ; First item in list
                (and (eq 'item (car context))
                     (not (eq (org-element-property :contents-begin context)
                              (org-element-property :contents-end context))))
                (unpackaged/org-element-descendant-of 'item context))  ; Element in list item, e.g. a link
            ;; Non-empty item: Add new item.
            (org-insert-item)
          ;; Empty item: Close the list.
          ;; TODO: Do this with org functions rather than operating on the text. Can't seem to find the right function.
          (delete-region (line-beginning-position) (line-end-position))
          ;; (org-indent-line)
          (insert "\n") ;; stay at original line
          )))

     ((when (fboundp 'org-inlinetask-in-task-p)
        (org-inlinetask-in-task-p))
      ;; Inline task: Don't insert a new heading.
      (org-return))

     ((org-at-table-p)
      (cond ((save-excursion
               (beginning-of-line)
               ;; See `org-table-next-field'.
               (cl-loop with end = (line-end-position)
                        for cell = (org-element-table-cell-parser)
                        always (equal (org-element-property :contents-begin cell)
                                      (org-element-property :contents-end cell))
                        while (re-search-forward "|" end t)))
             ;; Empty row: end the table.
             (delete-region (line-beginning-position) (line-end-position))
             (org-return))
            (t
             ;; Non-empty row: call `org-return'.
             (org-return))))
     (t
      ;; All other cases: call `org-return'.
      (org-return electric-indent-mode)))))
#+end_src

#+begin_src emacs-lisp :tangle yes
(defun scimax/org-return (&optional arg)
    "Add new list item, heading or table row with RET.
A double return on an empty element deletes it.
Use a prefix arg to get regular RET.
A prefix arg of 4 opens link in new window.
A prefix arg of 5 opens link in new frame."
    (interactive "P")
    (cond
     ;; single prefix arg, no fancy stuff, just org-return
     ((and arg (listp arg) (equal arg '(4)))
      (org-return))

     ((null arg)
      (cond

       ((eq 'line-break (car (org-element-context)))
        (org-return t))

       ;; Open links like usual, unless point is at the end of a line.
       ((and (eq 'link (car (org-element-context))) (not (eolp)))
        (org-return))

       ((looking-at org-heading-regexp)
        (org-return))


       ;; when you are here
       ;; * headline...
       ;;              ^
       ;; this rule is activated
       ;; ((and (bolp)
       ;;       ;; This avoids the case where you are at the beginning of a line that is not folded
       ;;       (save-excursion
       ;;         (let ((p (point)))
       ;;           (org-beginning-of-line)
       ;;           (not (= p (point)))))
       ;;       ;; This is a heuristic device where I found C-a C-e does not return
       ;;       ;; to the same place. I feel like this is new behavior since org
       ;;       ;; 9.5ish, but am not sure
       ;;       (save-excursion
       ;;         (let ((p (point)))
       ;;           (org-beginning-of-line)
       ;;           (org-end-of-line)
       ;;           (not (= p (point))))))
       ;;  (org-show-entry)
       ;;  (org-insert-heading))

       ;; It doesn't make sense to add headings in inline tasks. Thanks Anders
       ;; Johansson!
       ;; ((org-inlinetask-in-task-p)
       ;;  (org-return))

       ;; checkboxes - add new or delete empty
       ((org-at-item-checkbox-p)
        (cond
         ;; at the end of a line.
         ((and (eolp)
               (not (eq 'item (car (org-element-context)))))
          (org-insert-todo-heading nil))
         ;; no content, delete
         ((and (eolp) (eq 'item (car (org-element-context))))
          (delete-region (line-beginning-position) (point)))
         ((eq 'paragraph (car (org-element-context)))
          (goto-char (org-element-property :end (org-element-context)))
          (org-insert-todo-heading nil))
         (t
          (org-return))))

       ;; lists end with two blank lines, so we need to make sure we are also not
       ;; at the beginning of a line to avoid a loop where a new entry gets
       ;; created with only one blank line.
       ((org-in-item-p)
        (cond
         ;; empty definition list
         ((and (looking-at " ::")
               (looking-back "- " 3))
          (beginning-of-line)
          (delete-region (line-beginning-position) (line-end-position)))
         ;; empty item
         ((and (looking-at "$")
               (looking-back "- " 3))
          (beginning-of-line)
          (delete-region (line-beginning-position) (line-end-position)))
         ;; numbered list
         ((and (looking-at "$")
               (looking-back "[0-9]+. " (line-beginning-position)))
          (beginning-of-line)
          (delete-region (line-beginning-position) (line-end-position)))
         ((and (looking-at "$")
               (looking-at "^"))
          (org-return))
         ;; insert new item
         (t
          (end-of-line)
          (org-insert-item))))

       ;; org-heading
       ;; ((org-at-heading-p)
       ;;  (if (not (string= "" (org-element-property :title (org-element-context))))
       ;;      (progn
       ;;        ;; Go to end of subtree suggested by Pablo GG on Disqus post.
       ;;        (org-end-of-subtree)
       ;;        (org-insert-heading-respect-content)
       ;;        (outline-show-entry))
       ;;    ;; The heading was empty, so we delete it
       ;;    (beginning-of-line)
       ;;    (delete-region (line-beginning-position) (line-end-position))))

       ;; tables
       ((org-at-table-p)
        (if (-any?
             (lambda (x) (not (string= "" x)))
             (nth
              (- (org-table-current-dline) 1)
              (remove 'hline (org-table-to-lisp))))
            (org-return)
          ;; empty row
          (beginning-of-line)
          (delete-region (line-beginning-position) (line-end-position))
          (org-return)))
       ;; fall-through
       (t
        (org-return))))

     ;; other window,
     ((= arg 4)
      (clone-indirect-buffer-other-window (buffer-name) t)
      (org-return))

     ;; other frame
     ((= arg 5)
      (clone-frame)
      (org-return))

     ;; fall-through case
     (t
      (org-return))))
#+end_src

#+RESULTS:
: scimax/org-return

*** Org directory
#+begin_src emacs-lisp :tangle yes
;; If you use `org' and don't want your org files in the default location below,
;; change `org-directory'. It must be set before org loads!
(setq org-directory "~/Documents/Org")
#+end_src
*** Id/Attach
**** Set org attach directories

#+begin_src emacs-lisp :tangle yes
(after! org
  (setq org-attach-id-dir (expand-file-name ".attach/" org-directory)))
#+end_src

*** Agenda
**** Agenda Files
#+begin_src emacs-lisp :tangle yes
(setq org-agenda-files '("personal.org" "medical-school.org" "inbox.org"))
#+end_src
**** Appearance
#+begin_src emacs-lisp :tangle yes
(after! org-agenda
  (setq org-agenda-skip-scheduled-if-done t
        org-agenda-skip-deadline-if-done t
        org-agenda-skip-scheduled-if-done t
        org-agenda-skip-scheduled-if-deadline-is-shown t
        org-agenda-skip-timestamp-if-deadline-is-shown t
        org-agenda-compact-blocks t
        org-agenda-include-deadlines t
        org-agenda-follow-indirect t
        org-agenda-block-separator nil))
#+end_src

**** Org-expiry
#+begin_src emacs-lisp :tangle no
(package! org-expiry)
#+end_src

#+begin_src emacs-lisp :tangle yes
(use-package! org-expiry
  :after org
  :config
  (setq org-expiry-created-property-name "CREATED"
        org-expiry-inactive-timestamps t))
#+end_src

**** COMMENT Time Grid
#+begin_src emacs-lisp :tangle yes
(after! org
  (setq org-agenda-time-grid '((daily) () "" "")
        org-agenda-use-time-grid nil))
#+end_src

**** Start week on Sunday
#+begin_src emacs-lisp :tangle yes
(after! org
  (setq org-agenda-start-on-weekday 0
        org-agenda-span 'week
        ;; org-agenda-start-day "+0d"
        ))
#+end_src


**** Leader key bindings
For some reason the emacs bindings for agend are not included under the =doom-leader-open-keymap=. Adding them back in.
#+begin_src emacs-lisp :tangle yes
(map! :map doom-leader-open-map
        :desc "Agenda" "A" #'org-agenda
        (:prefix ("a" . "org agenda")
        :desc "Agenda"         "a"  #'org-agenda
        :desc "Todo list"      "t"  #'org-todo-list
        :desc "Tags search"    "m"  #'org-tags-view
        :desc "View search"    "v"  #'org-search-view))
#+end_src
**** COMMENT Org-gtd
#+begin_src emacs-lisp :tangle packages.el
(package! org-gtd)
#+end_src

#+begin_src emacs-lisp :tangle yes
(use-package! org-gtd
  :after org
  :init
  (setq org-gtd-update-ack "3.0.0")
  :config
  (setq org-edna-use-inheritance t
        org-gtd-directory (expand-file-name "Agenda/" org-directory))
  (org-edna-mode)
  (map! :leader
        (:prefix ("d" . "gtd")
                 "c" #'org-gtd-capture
                 "e" #'org-gtd-engage
                 "p" #'org-gtd-process-inbox
                 "n" #'org-gtd-show-all-next
                 "s" #'org-gtd-review-stuck-projects))
  (map! :map org-gtd-clarify-map
        "C-c C-c" #'org-gtd-organize))
#+end_src

**** Org Super Agenda
#+begin_src emacs-lisp :tangle packages.el
(package! org-super-agenda)
#+end_src

#+begin_src emacs-lisp :tangle yes
(use-package! org-super-agenda
  :after org
  :config
  (org-super-agenda-mode 1)
  (setq org-super-agenda-groups '(;; Each group has an implicit boolean OR operator between its selectors.

         ;; This is the first filter, anything found here
         ;; will be placed in this group
         ;; even if it matches following groups
         (:name " Overdue" ; Name
                :scheduled past ; Filter criteria
                :deadline past
                :order 2 ; Order it should appear in agenda view
                :face 'error) ; Font face used for text

         ;; This is the second filter, anything not found
         ;; from the first filter, but found here,
         ;; will be placed in this group
         ;; even if it matches following groups
         (:name " Personal" ; Name
                :file-path "personal" ; Filter criteria
                :order 3 ; Order it should appear in the agenda view
                ) ; Font faced used for text

         ;; Third filter..
         (:name " School"  ; Name
                :file-path "school" ; Filter criteria
                :order 3 ; Order it should appear in the agenda view
                ) ; Font face used for text

         ;; Fourth filter..
         (:name " Today "  ; Optionally specify section name
                :time-grid t ; Use the time grid
                :date today ; Filter criteria
                :scheduled today ; Another filter criteria
                :order 1 ; Order it should appear in the agenda view
                ) ; Font face used for text

        )))
#+end_src


**** Agendas
#+begin_src emacs-lisp :tangle yes :noweb yes
(setq org-agenda-custom-commands
      '(
        <<agenda-gtd>>
        ))
#+end_src
***** Default
#+begin_src emacs-lisp :tangle no :noweb-ref agenda-default
#+end_src
***** GTD
Basic gtd agenda (taken from https://github.com/rougier/emacs-gtd)
#+begin_src emacs-lisp :tangle no :noweb-ref agenda-gtd
("g" "Get Things Done (GTD)"
         ((todo "SCHEDULED<=\"<today\""
                ((org-agenda-overriding-header "\nOVERDUE TASKS\n")))
          (tags "inbox"
                     ((org-agenda-prefix-format "  %?-12t% s")
                      (org-agenda-overriding-header "\nInbox: clarify and organize\n")
                      ;; hide inbox tag; we already know they're inbox entries
                      (org-agenda-hide-tags-regexp "inbox")))
          (agenda nil
                  ((org-scheduled-past-days 0)
                   (org-deadline-warning-days 0)
                   (org-agenda-start-day "+0d")
                   (org-agenda-span 2)
                   (org-super-agenda-groups
                    '((:name "Today"
                       :time-grid t
                       :date today
                       :scheduled today
                       :order 1)
                      ;; (:name "Tomorrow"
                      ;;        :time-grid t
                      ;;        :date tomorrow
                      ;;        :scheduled tomorrow
                      ;;        :order 2)
                      ))))
          (todo "TODO"
                ((org-agenda-skip-function
                  '(org-agenda-skip-entry-if 'deadline 'scheduled))
                 (org-agenda-prefix-format "  %i %-12:c [%e] ")
                 (org-agenda-overriding-header "\nTasks: can be done\n")))
          (todo "HOLD"
                ((org-agenda-prefix-format "  %i %-12:c [%e] ")
                 (org-agenda-overriding-header "\nTasks: on hold\n")))
          (todo "STRT"
                ((org-agenda-prefix-format "  %i %-12:c [%e] ")
                 (org-agenda-overriding-header "\nTask: active \n")))
          (tags "CLOSED>=\"<today>\""
                ((org-agenda-overriding-header "\nCompleted today\n")))
          (agenda nil
                  ((org-agenda-entry-types '(:deadline))
                   ;; (org-agenda-format-date "")
                   (org-agenda-start-day "+0d")
                   (org-deadline-warning-days 0)
                   (org-agenda-span 'week)
                   (org-agenda-use-time-grid nil)
                   ;; (org-agenda-skip-function
                   ;;  '(org-agenda-skip-entry-if 'notregexp "\\* NEXT"))
                   (org-agenda-overriding-header "\nDeadlines")))

          ))
#+end_src

**** Keywords for todo
Largely identical to doom's default but I want to replace KILL with CNCL
#+begin_src emacs-lisp :tangle yes
(after! org
  (setq org-todo-keywords '((sequence
           "TODO(t)"  ; A task that needs doing & is ready to do
           "PROJ(p)"  ; A project, which usually contains other tasks
           "LOOP(r)"  ; A recurring task
           "STRT(s)"  ; A task that is in progress
           "WAIT(w)"  ; Something external is holding up this task
           "HOLD(h)"  ; This task is paused/on hold because of me
           "IDEA(i)"  ; An unconfirmed and unapproved task or notion
           "|"
           "DONE(d)"  ; Task successfully completed
           "CNCL(c)") ; Task was cancelled, aborted, or is no longer applicable
          (sequence
           "[ ](T)"   ; A task that needs doing
           "[-](S)"   ; Task is in progress
           "[?](W)"   ; Task is being held up or paused
           "|"
           "[X](D)")  ; Task was completed
          (sequence
           "|"
           "OKAY(o)"
           "YES(y)"
           "NO(n)"))))
#+end_src
**** Tags
:PROPERTIES:
:CREATED:  [2025-04-12 Sat 14:28]
:END:
#+begin_src emacs-lisp :tangle yes :noweb yes
(after! org
  (setq org-tag-alist '(
                        <<tags-gtd>>
                        <<tags-location>>
                        <<tags-action>>
                        )))
#+end_src
***** GTD tags
:PROPERTIES:
:CREATED:  [2025-04-12 Sat 14:30]
:header-args: :noweb-ref tags-gtd
:END:
#+begin_src emacs-lisp :tangle no
(:startgrouptag)
("GTD")
(:grouptags)
("calendar")
("inbox")
(:endgrouptag)

;; calendar subtags
(:startgrouptag)
("meeting")
("event")
("appointment")
(:endgrouptag)

(:endgrouptag)
#+end_src

***** Location tags
:PROPERTIES:
:CREATED:  [2025-04-12 Sat 14:31]
:header-args: :noweb-ref tags-location
:END:
#+begin_src emacs-lisp :tangle no
(:startgroup . nil)
("@school" . ?s)
("@home" . ?h)
(:endgroup . nil)
#+end_src
***** COMMENT Action tags
:PROPERTIES:
:CREATED:  [2025-04-12 Sat 14:35]
:header-args: :noweb-ref tags-action
:END:
#+begin_src emacs-lisp :tangle no
(:startgrouptag)
("Action")
(:grouptags)
("communicate")
(:endgrouptag)

;; communicate subtags
(:startgrouptag)
("communicate")
(:grouptags)
("email")
("text")
(:endgrouptag)

(:endgrouptag)
#+end_src
**** Log
#+begin_src emacs-lisp :tangle yes
(after! org
  (setq org-log-into-drawer t))
#+end_src

**** Org timeblock
#+begin_src emacs-lisp :tangle packages.el
(package! org-timeblock)
#+end_src

#+begin_src emacs-lisp :tangle yes
(use-package! org-timeblock
  :after org)
#+end_src
*** Capture
**** Doct
Use doct for improved org-capture template creation.
#+begin_src emacs-lisp :tangle packages.el
(package! doct)
#+end_src

#+begin_src emacs-lisp :tangle yes
(use-package! doct
  :commands doct
  :after org)
#+end_src

**** Capture Templates
#+begin_src emacs-lisp :tangle yes
(after! (:and org denote)
  (setq org-capture-templates (doct '(("Inbox"
                                       :keys "i"
                                       :file "inbox.org"
                                       :type entry
                                       :prepend t
                                       :template ("* %?"
                                                  ":PROPERTIES:"
                                                  ":CREATED: %U"
                                                  ":END:"
                                                  "%i"
                                                  "%a")
                                       :kill-buffer t
                                       )
                                      ("Todo" :keys "t"
                                       :file "inbox.org"
                                       :type entry
                                       :prepend t
                                       :template ("* TODO %?"
                                                  ":PROPERTIES:"
                                                  ":CREATED: %U"
                                                  ":END:"
                                                  "%i"
                                                  "%a"))
                                      ("Calendar" :keys "c"
                                       :file "inbox.org"
                                       :type entry
                                       :prepend t
                                       :template ("* %? :calendar:"
                                                  ":PROPERTIES:"
                                                  ":CREATED: %U"
                                                  ":END:"
                                                  "%i"))
                                      ("Meeting" :keys "m"
                                       :file "inbox.org"
                                       :type entry
                                       :prepend t
                                       :template ("* %? :meeting:"
                                                  ":PROPERTIES:"
                                                  ":CREATED: %U"
                                                  ":END:"
                                                  "%i"))
                                      ("Email" :keys "@"
                                       :file "inbox.org"
                                       :type entry
                                       :prepend t
                                       :template ("* %? :email:"
                                                  ":PROPERTIES:"
                                                  ":CREATED: %U"
                                                  ":END:"
                                                  "%i"))
                                      ("Project" :keys "p"
                                       :file "inbox.org"
                                       :type entry
                                       :prepend t
                                       :template ("* PROJ %?"
                                                  ":PROPERTIES:"
                                                  ":CREATED: %U"
                                                  ":END:"
                                                  "%i"))
                                      ("School" :keys "s"
                                       :file "medical-school.org"
                                       )
                                      )))
)
#+end_src


#+begin_src emacs-lisp :tangle no
(("i" "Inbox" entry (file ) "* %?\n%U\n\n  %i" :kill-buffer t)
 ("l" "Inbox with link" entry (file org-gtd-inbox-path) "* %?\n%U\n\n  %i\n  %a"
  :kill-buffer t)
 ("y" "Inbox with clipboard" (file)))
#+end_src

#+begin_src emacs-lisp :tangle no
(("t" "Personal todo" entry (file+headline +org-capture-todo-file "Inbox")
  "* [ ] %?\n%i\n%a" :prepend t)
 ("n" "Personal notes" entry (file+headline +org-capture-notes-file "Inbox")
  "* %u %?\n%i\n%a" :prepend t)
 ("j" "Journal" entry (file+olp+datetree +org-capture-journal-file)
  "* %U %?\n%i\n%a" :prepend t)
 ("p" "Templates for projects")
 ("pt" "Project-local todo" entry
  (file+headline +org-capture-project-todo-file "Inbox") "* TODO %?\n%i\n%a"
  :prepend t)
 ("pn" "Project-local notes" entry
  (file+headline +org-capture-project-notes-file "Inbox") "* %U %?\n%i\n%a"
  :prepend t)
 ("pc" "Project-local changelog" entry
  (file+headline +org-capture-project-changelog-file "Unreleased")
  "* %U %?\n%i\n%a" :prepend t)
 ("o" "Centralized templates for projects")
 ("ot" "Project todo" entry #'+org-capture-central-project-todo-file
  "* TODO %?\n %i\n %a" :heading "Tasks" :prepend nil)
 ("on" "Project notes" entry #'+org-capture-central-project-notes-file
  "* %U %?\n %i\n %a" :heading "Notes" :prepend t)
 ("oc" "Project changelog" entry #'+org-capture-central-project-changelog-file
  "* %U %?\n %i\n %a" :heading "Changelog" :prepend t))
#+end_src

*** Clock
**** Pomodoro
***** Add clock icon to pomodoro timer
#+begin_src emacs-lisp :tangle yes
(after! org-pomodoro
  (setq org-pomodoro-format " %s"
        org-pomodoro-short-break-format " Short Break %s"
        org-pomodoro-long-break-format " Long Break %s"))
#+end_src
***** Prompt to start a new pomodoro after a break
Prompt the user to start a new pomodoro after taking a break. Taken from:
https://github.com/marcinkoziej/org-pomodoro/issues/89#issuecomment-1058725921

#+begin_src emacs-lisp :tangle yes
(after! org-pomodoro
  (defun my/org-pomodoro-restart ()
    (interactive)
    (let ((use-dialog-box nil))
      (when (y-or-n-p "Start a new pomodoro?")
        (save-window-excursion
          (org-clock-goto)
          (org-pomodoro)))))
  (add-hook 'org-pomodoro-break-finished-hook 'my/org-pomodoro-restart))
#+end_src
*** Appearance
**** COMMENT Org ellipsis
#+begin_src emacs-lisp :tangle yes
(after! org
  (setq org-ellipsis " […]"))
#+end_src

*** Notes
**** Denote

#+begin_src emacs-lisp :tangle packages.el
(package! denote)
#+end_src

#+begin_src emacs-lisp :tangle yes
(use-package! denote
  :hook
  (dired-mode . denote-dired-mode)
  :custom
  (denote-directory "~/Documents/Org/Notes")
  (denote-backlinks-show-context t)
  (denote-date-prompt-use-org-read-date t)
  (denote-infer-keywords t)
  (denote-sort-keywords t)
  :bind
  (("C-c n d n" . denote-open-or-create)
   ("C-c n d f" . denote-open-or-create)
   ("C-c n d c" . denote-region)
   ("C-c n d N" . denote-type)
   ("C-c n d d" . denote-date)
   ("C-c n d z" . denote-signature)
   ;; ("C-c n d s" . denote-subdirectory)
   ("C-c n d t" . denote-template)
   ("C-c n d i" . denote-link-or-create)
   ("C-c n d l" . denote-link-or-create)
   ("C-c n d I" . denote-add-links)
   ("C-c n d b" . denote-backlinks)
   ("C-c n d r" . denote-rename-file)
   ("C-c n d R" . denote-rename-file-using-front-matter)
   ("C-c n d g" . denote-grep))
  :config
  ;; hack
  ;; (setq denote-use-directory denote-directory)
  (after! org-capture
    (add-to-list 'org-capture-templates
                 '("n" "New note (with Denote)" plain
                   (file denote-last-path)
                   #'denote-org-capture
                   :no-save t
                   :immediate-finish nil
                   :kill-buffer t
                   :jump-to-captured t)))
  (setq denote-history-completion-in-prompts '(denote-signature-prompt denote-files-matching-regexp-prompt denote-query-link-prompt))
  (after! vertico-multiform
    ;; preselect the prompt when creating a new note
    (add-to-list 'vertico-multiform-commands '(denote-open-or-create (vertico-preselect . prompt)))
    (add-to-list 'vertico-multiform-commands '(denote (vertico-preselect . prompt))))
  ;; word wrap backlinks and query buffers
  (when (modulep! :editor word-wrap)
    (add-to-list '+word-wrap-text-modes 'denote-query-mode))
  (denote-rename-buffer-mode 1))
#+end_src

***** Consult Denote
#+begin_src emacs-lisp :tangle packages.el
(package! consult-denote)
#+end_src

#+begin_src emacs-lisp :tangle yes
(use-package! consult-denote
  :after (consult denote)
  :bind
  ([remap denote-grep] . consult-denote-grep)
  :init
  (consult-denote-mode))
#+end_src

***** Denote Org
#+begin_src emacs-lisp :tangle packages.el
(package! denote-org)
#+end_src

#+begin_src emacs-lisp :tangle yes
(use-package! denote-org
  :after (denote org))
#+end_src
***** Denote Journal
#+begin_src emacs-lisp :tangle packages.el
(package! denote-journal)
#+end_src

#+begin_src emacs-lisp :tangle yes
(use-package denote-journal
  :after denote
  ;; Bind those to some key for your convenience.
  :commands ( denote-journal-new-entry
              denote-journal-new-or-existing-entry
              denote-journal-link-or-create-entry )
  :hook (calendar-mode . denote-journal-calendar-mode)
  :config
  ;; Use the "journal" subdirectory of the `denote-directory'.  Set this
  ;; to nil to use the `denote-directory' instead.
  (setq denote-journal-directory
        (expand-file-name "journal" denote-directory))
  ;; Default keyword for new journal entries. It can also be a list of
  ;; strings.
  (setq denote-journal-keyword "journal")
  ;; Read the doc string of `denote-journal-title-format'.
  (setq denote-journal-title-format "%Y-%m-%d %a"))
#+end_src

#+begin_src emacs-lisp :tangle yes
(after! org-capture
  (add-to-list 'org-capture-templates
               '("j" "Journal" entry
                 (file denote-journal-path-to-new-or-existing-entry)
                 "* %U %?\n%i\n%a"
                 :kill-buffer t
                 :empty-lines 1)))
#+end_src
***** Denote Explorer
#+begin_src emacs-lisp :tangle packages.el
(package! denote-explore)
#+end_src

#+begin_src emacs-lisp :tangle yes
(use-package! denote-explore
  :after denote
  :bind
  (;; Statistics
   ("C-c n d s n" . denote-explore-count-notes)
   ("C-c n d s k" . denote-explore-count-keywords)
   ("C-c n d s e" . denote-explore-barchart-filetypes)
   ("C-c n d s w" . denote-explore-barchart-keywords)
   ("C-c n d s t" . denote-explore-barchart-timeline)
   ;; Random walks
   ("C-c n d w n" . denote-explore-random-note)
   ("C-c n d w r" . denote-explore-random-regex)
   ("C-c n d w l" . denote-explore-random-link)
   ("C-c n d w k" . denote-explore-random-keyword)
   ;; Janitor
   ("C-c n d j d" . denote-explore-duplicate-notes)
   ("C-c n d j D" . denote-explore-duplicate-notes-dired)
   ("C-c n d j l" . denote-explore-missing-links)
   ("C-c n d j z" . denote-explore-zero-keywords)
   ("C-c n d j s" . denote-explore-single-keywords)
   ("C-c n d j r" . denote-explore-rename-keywords)
   ("C-c n d j y" . denote-explore-sync-metadata)
   ("C-c n d j i" . denote-explore-isolated-files)
   ;; Visualize
   ("C-c n d v n" . denote-explore-network)
   ("C-c n d v r" . denote-explore-network-regenerate)
   ("C-c n d v d" . denote-explore-barchart-degree)
   ("C-c n d v b" . denote-explore-barchart-backlinks)))
#+end_src
***** Denote Menu
#+begin_src emacs-lisp :tangle packages.el
(package! denote-menu)
#+end_src

#+begin_src emacs-lisp :tangle yes
(use-package! denote-menu
  :after denote
  :bind
  (("C-c n d m" . list-denotes)
   :map denote-menu-mode-map
   ("c" . #'denote-menu-clear-filters)
   ("f" . #'denote-menu-filter)
   ("k" . #'denote-menu-filter-by-keyword)
   ("o" . #'denote-menu-filter-out-keyword)
   ("e" . #'denote-menu-export-to-dired))
  :config
  ;; Prefer `ripgrep' and `fd' variants when available
  (when (executable-find "fd")
    (setopt consult-denote-find-command #'consult-fd))
  (when (executable-find "rg")
    (setopt consult-denote-grep-command #'consult-ripgrep))
  )
#+end_src

*** Org Noter
**** Fix undeletable pdf buffer after ending =org-noter-session=
#+begin_src emacs-lisp :tangle yes
;; HACK Prevents strange behavior interacting betwee org-noter and persp-mode that prevents the new frame from being closed. Avoid this by just preventing a new frame from being made in the first place.
(after! org-noter
  (setq org-noter-always-create-frame nil
        org-noter-kill-frame-at-session-end nil)
  (after! vertico-multiform
    (add-to-list 'vertico-multiform-commands '(org-noter-insert-note (vertico-preselect . prompt)))))
#+end_src
** Nix
*** Use alejandra as formatter

#+begin_src emacs-lisp :tangle yes
(after! nix-mode
  (set-formatter! 'alejandra '("alejandra" "--quiet") :modes '(nix-mode)))
#+end_src

* Email
* App
* Personal
** Identify
#+begin_src emacs-lisp :tangle yes
;; Some functionality uses this to identify you, e.g. GPG configuration, email
;; clients, file templates and snippets. It is optional.
(setq user-full-name "Kevin Rao"
      user-mail-address "kevinrao2000@gmail.com")
#+end_src
** Poll Everywhere
#+begin_src emacs-lisp :tangle yes
(defun +poll-everywhere (instructor)
  "Open poll everywhere page for INSTRUCTOR."
  (interactive "sInstructor: ")
  (browse-url (concat "https://pollev.com/" instructor)))
#+end_src
